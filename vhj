Mapping A — GFCID-EXCP → Reformat → LR-shaped stream

What it does (in words):
We take raw GFCID exception rows and reshape them into the LR schema. All business keys and contextual fields are passed through; an exception envelope (giw_exception) is constructed from EXCP attributes; and audit fields are stamped.

Transform (Reformat) logic used:

Helper includes and constants are set once: we import genUUID.xfr, compute CURRENT_DATE = date("YYYYMMDD") now(), and LST_UPD_TIME = datetime_to_unixtime(utc_now()) * 100.

Field mapping is a straight pass-through for identifiers and period columns; exception fields are bundled.

Pseudocode of the transform (exact intent):

/* helpers */
include "~${AI_XFR}/genUUID.xfr";
let date("YYYYMMDD") CURRENT_DATE = date("YYYYMMDD") now();
let decimal(..., sign_reserved) LST_UPD_TIME = datetime_to_unixtime(utc_now())*100;

/* LR fields */
out.gfcid       :: in.gfcid;
out.id_type     :: in.id_type;
out.batch_dt    :: in.batch_dt;
out.client_type :: in.client_type;
out.month       :: in.month;
out.year        :: in.year;
out.country     :: in.country;

/* business exception built from EXCP attributes */
out.giw_exception :: build_exception(
   code  => in.exception_cd,
   bu    => in.giw_business_unit,
   owner => in.primary_owner_business_unit
);

/* audit, if present in ${TABLE}_type */
out.lst_upd_dt   :: CURRENT_DATE;
out.lst_upd_id   :: '${CREATE_ID}';
out.lst_upd_time :: LST_UPD_TIME;


Source → Target fields (summary):
gfcid,id_type,batch_dt,client_type,month,year,country → same names in LR;
exception_cd,giw_business_unit,primary_owner_business_unit → giw_exception (constructed object/record).

Emitted to: LR-shaped stream (goes to Concatenate).

Subgraph — “CIN Exceptions (Read Only)”

What it does (in words):
Inside the subgraph, we inner-join the staging LR rows (STG LR) with a CIN lookup (CIN-EXCP) on {id, country} to identify records with a CIN exception. For every match, we keep the LR keys from STG and construct a CIN-specific exception payload for giw_exception. Audit stamps are added the same way.

Inputs:

STG LR (LR-like rows)

CIN-EXCP (cin_lookup record)

Join parameters / keys / type:

count = 2

sorted-input = False

key = { id; country }

join-type = Inner (only matched rows become exceptions)

Pseudocode of the subgraph’s Join transform:

include "~${AI_XFR}/genUUID.xfr";
let date("YYYYMMDD") CURRENT_DATE = date("YYYYMMDD") now();
let decimal(..., sign_reserved) LST_UPD_TIME = datetime_to_unixtime(utc_now())*100;

/* out from inner-join: keep LR keys from STG and build the CIN exception */
out.gfcid       :: in0.gfcid;     /* STG LR */
out.id_type     :: in0.id_type;
out.batch_dt    :: in0.batch_dt;
out.client_type :: in0.client_type;
out.month       :: in0.month;
out.year        :: in0.year;
out.country     :: in0.country;

/* CIN-derived business exception */
out.giw_exception :: build_cin_exception(
   cin_code   => in1.cin_code,
   cin_reason => in1.cin_reason,
   cin_source => in1.cin_source
);

/* audit */
out.lst_upd_dt   :: CURRENT_DATE;
out.lst_upd_id   :: '${CREATE_ID}';
out.lst_upd_time :: LST_UPD_TIME;


Source → Target fields (summary):
From STG LR: gfcid,id_type,batch_dt,client_type,month,year,country → same in LR;
From CIN-EXCP: cin_code,cin_reason,cin_source → giw_exception (constructed).

Emitted to: LR-shaped stream (goes to Concatenate).

Concatenate — merge the two exception streams

What it does (in words):
The Concatenate component performs a UNION ALL of the two LR-shaped streams (GFCID exceptions and CIN exceptions) without sorting or deduplication. This yields a single, combined LR exception feed.

Why Concatenate is correct here:
Both upstream branches already conform to the same LR record type (${TABLE}_type) and carry their own giw_exception payloads; therefore appending is safe and preserves full lineage.

Target — LR File

What it does (in words):
The LR File accepts the concatenated stream and writes it using the main LR DML:
include "~${AI_DML}/kyc_interface_giw_main_table.dml"; metadata type = ${TABLE}_type.

Effective columns written (based on your DML excerpts):
gfcid, id_type, batch_dt, client_type, month, year, country, giw_exception
(+ audit columns such as lst_upd_dt, lst_upd_id, lst_upd_time if defined in ${TABLE}_type).

Parameters & runtime constants used (complete list)

include "~${AI_XFR}/genUUID.xfr"; (utility functions)

CURRENT_DATE = date("YYYYMMDD") now();

LST_UPD_TIME = datetime_to_unixtime(utc_now()) * 100;

${CREATE_ID} (populates lst_upd_id)

${AI_DML} (base path for DML includes)

${TABLE}_type (final LR record type)

${STG_TABLE}_type (staging LR record type, used inside the subgraph)

Put simply (one-line per branch)

GFCID-EXCP → Reformat → (LR-shape): pass keys & period fields, wrap EXCP attributes into giw_exception, stamp audit.

STG LR ⨝ CIN-EXCP (Inner): keep LR keys from STG, derive giw_exception from CIN match, stamp audit.

Concatenate: append both LR streams.

LR File: write out using ${TABLE}_type in kyc_interface_giw_main_table.dml.

If you want this duplicated for the earlier LR_1 plan (with BT/MUT/ET/reject/log/unused), say “do LR_1 too” and I’ll lay it out in the same sentence-plus-logic style.
